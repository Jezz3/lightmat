import astropy.units as u
from astropy.constants import hbar, c, eps0, e, a0, h, hbar
import numpy as np
import pandas as pd
from sympy.physics.wigner import wigner_3j, wigner_6j
from typing import Union
from collections.abc import Sequence
from typing import Union

from .light import Laser
from .matter import Atom

class Potential(object):
    
    def __init__(
            self,
            lasers: Union[Laser, Sequence[Laser]],
            atom: Atom, 
    ) -> None:
        """Initialise the Potential object.
        
           Args:
               lasers: Laser or sequence of lasers used to generate the potential. If a laser has several beams,
                       they all interfere with each other to generate a potential. The potential generated by each
                       laser is then summed up to get the total potential.
               atom: Atom object representing the atom for which the potential is to be generated.
        """
        self.lasers = lasers
        self.atom = atom
        self._check_input("init")




    def V(
            self,
            x: Union[float, Sequence[float], np.ndarray, u.Quantity], 
            y: Union[float, Sequence[float], np.ndarray, u.Quantity], 
            z: Union[float, Sequence[float], np.ndarray, u.Quantity],
    ) -> u.Quantity:
        """Returns the potential of the `atom` in its hfs state given the light field of the `lasers` at the position (x,y,z) in [h x MHz]. 
           Here, x, y, z are the global standard Carteesian coordinates in [um] and can be either float or array obtained from np.meshgrid().

           Args:
                x: Global standard Carteesian coordinate in [um].
                y: Global standard Carteesian coordinate in [um].
                z: Global standard Carteesian coordinate in [um].

           Returns:
                u.Quantity: Complex electric field amplitude of the beam at the position (x,y,z) in [V/m], can be either float or array.
        """
        for laser in self.lasers:
            # Calculate the electric field amplitude of the laser at the position (x,y,z)
            E_squared = np.real(laser.E(x, y, z) * np.conj(laser.E(x, y, z))) # this is real anyways, just get rid of complex cast warnings

            # Calculate the polarizabilities of the atom in the hfs state for the laser frequency
            alpha_s = self.atom.scalar_hfs_polarizability(laser.omega)
            alpha_v = self.atom.vector_hfs_polarizability(laser.omega)
            alpha_t = self.atom.tensor_hfs_polarizability(laser.omega)

            # Calculate the coefficients, equation (20) in http://dx.doi.org/10.1140/epjd/e2013-30729-x
            C = 2 * np.imag(0)




    def _check_input(
            self, 
            method: str,
    ) -> None:
        if method == "init":
            # Check lasers
            if isinstance(self.lasers, Sequence):
                if not all(isinstance(laser, Laser) for laser in self.lasers):
                    raise TypeError("lasers must be a Laser or sequence of Lasers")
            else:
                if not isinstance(self.lasers, Laser):
                    raise TypeError("lasers must be a Laser or sequence of Lasers")
                else:
                    self.lasers = [self.lasers]

            # Check atom
            if not isinstance(self.atom, Atom):
                raise TypeError(f"atom must be an instance of Atom, not {type(self.atom)}")