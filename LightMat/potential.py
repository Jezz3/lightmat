import os
import astropy.units as u
from astropy.constants import hbar, c, eps0, e, a0, h, hbar
import numpy as np
import pandas as pd
import pywigxjpf as wig
from typing import Union
from collections.abc import Sequence

from .light import Laser
from .matter import Atom

class Potential(object):
    
    def __init__(
            self,
            lasers: Union[Laser, Sequence[Laser]],
            atom: Atom, 
    ) -> None:
        """Initialise the Potential object.
        
           Args:
               lasers: Laser or sequence of lasers used to generate the potential. If a laser has several beams,
                       they all interfere with each other to generate a potential. The potential generated by each
                       laser is then summed up to get the total potential.
               atom: Atom object representing the atom for which the potential is to be generated.
        """
        self.lasers = lasers
        self.atom = atom
        self._check_input("init")





    def _fs_polarizability(
            self,
            K: int,
            omega_laser: u.Quantity,
    ) -> float:
        """Calculate the scalar (K=0), vector (K=1) or tensor (K=2) polarizability of the 
           atomic fine structure state.
        """
        J = self.atom.hfs_state['J']

        alpha = 0
        for _, row in self.atom.fs_transition_data.iterrows():
            J_prime = row['transition']['J']
            reduced_dipole_element = row['reduced_dipole_element'] * e.si * a0
            omega_transition = row['wavelength'] * u.MHz
            gamma_transition = row['linewidth'] * u.MHz


            alpha += (-1)**(K+J+1+J_prime) * wig.wig6jj(1, K, 1, J, J_prime, J) * reduced_dipole_element**2 * \
                     1/hbar * np.real(1/(omega_transition - omega_laser - 1j*gamma_transition/2) + \
                                      (-1)**K/(omega_transition + omega_laser + 1j*gamma_transition/2))

        return np.sqrt(2*K + 1) * alpha





    def _check_input(
            self, 
            method: str,
    ) -> None:
        if method == "init":
            # Check lasers
            if isinstance(self.lasers, Sequence):
                if not all(isinstance(laser, Laser) for laser in self.lasers):
                    raise TypeError("lasers must be a Laser or sequence of Lasers")
            else:
                if not isinstance(self.lasers, Laser):
                    raise TypeError("lasers must be a Laser or sequence of Lasers")

            # Check atom
            if not isinstance(self.atom, Atom):
                raise TypeError(f"atom must be an instance of Atom, not {type(self.atom)}")